# studySpring

## Spring 동작 방식

* 정적 컨텐츠의 동작 : 해당 요청이 들어오면 스프링 컨테이너가 정적 컨텐츠 관련 컨트롤러를 찾으려함 정적 컨텐츠이므로 컨트롤러가 없어서 resources 내부에 있는 정적 파일을 그대로 화면으로 띄움

* MVC와 템플릿 엔진 : 해다 요청이 들어오면 스프링 컨테이너가 해당 컨트롤러를 찾음 해당 컨트롤러가 반환하는 view를 viewResolver가 찾아서 템플릿 엔진이 처리하여 화면으로 띄움

* API : 어노테이션 @ResponseBody 추가 해당 어노테이션이 추가되면 viewResolver를 사용X 대신 HTTP 응답 방식의 Body에 리턴 값을 직접 반환한다. 보통 객체를 반환한다. -> JSON형식

## 스프링 파일 터미널에서 실행하기

```
$ ./gradlew build 
$ cd /build/libs
$ java -jar [파일이름].jar
```

-------

## 회원 레포 구현 및 테스트 케이스 생성

* 회원 객체 생성(domain) 후 레포 구현 (레포지토리 패키지 -> 멤버 레포 인터페이스 -> 메모리 멤버 레포 클래스 생성)
* 레포에서 쓸 메서드들 구현 (save, findById, findByName, findAll, clearStore) id는 sequence로 하나씩 올려가면서 시스템 자체에서 생성
* 테스트 케이스 생성 -> 테스트파일은 각각의 메서드에 의존관계 없이 생성해야함 -> 따라서 clearStore 만듦 clearStore는 AfterEach로 각각의 메서드가 끝날때맏 실행 -> 기록 지워짐
* 테스트 케이스를 먼저 생성 후 구현하는 방식의 코딩 스타일 (TTD라고 함)

## 회원 서비스 구현 및 테스트 케이스 생성

* 회원 서비스 (회원가입, 유저 리스트 조회, 아이디로 유저 조회) 구현
* 회원가입에 이름이 중복되면 회원 가입 불가 하는 로직 구현 및 리팩토링
* 테스트 케이스 생성
* 테스트 케이스 생성 중 회원 서비스에서 new로 생성하는 레포가 문제 발생 가능성이 있음을 배움
* 따라서, 직접 new로 생성하는것이 아니라 외부에서 넣어 주는 개념(DI)으로 생성자로 레포를 넣어줌
* 테스트 케이스에서 BeforeEach 어노테이션으로 모든 테스트 메서드가 실행되기전에 실행

## 컴포넌트 스캔 및 스프링 설정 파일로 스프링 컨테이너에 등록

* 스프링에서 동작하려면 Controller(외부에서 들어오는 요청 처리) - Service(로직 구현) - Repository(데이터 저장) 순으로 의존 관계가 이루어져 있어야 함.
* 모든 것이 스프링 빈으로 등록되어야지만 스프링이 관리 가능함으로 의존관계가 성립 가능
* 스프링 빈으로 등록하는 방법은 컴포넌트 스캔방식, 스프링 설정파일(SpringConfig)이용 이렇게 두가지 방식이 존재
* 컴포넌트 스캔 방식은 @Controller, @Service, @Repository의 어노테이션들을 각각 붙인 다음에 @Autowired로 생성자 주입을 통해 의존관계를 성립시켜주는 방식
* 스프링 설정파일을 통해 등록하는 방식은 직접 파일을 만든 후, @Configuration, @Bean 어노테이션을 통해 직접 등록해주는 방식
* 정형화되고 바꿀 일이 없는 클래스들은 보통 컴포넌트 스캔방식을 이용, 하지만 현재 예제에서와 같이 DB를 바꿀예정이거나 클래스들을 교체해야 하는 서비스의 경우에는 설정파일에서 쉽게 교체 가능하기 때문에 설정파일 방식을 이용

## 회원 웹 기능

* 컨트롤러에서 요청을 전달받은 뒤에 해당 요청을 처리하는 컨트롤러 속 메서드로 이동.. 해당 메서드에서 요청을 처리한 뒤에 반환값 이름을 가지는 파일로 이동하여 해당 파일을 화면에 띄움

## 스프링 DB 접근 기술

* H2데이터베이스 설치
* 순수 JDBC -> 스프링 JdbcTemplate -> JPA -> 스프링 데이터 JPA 순으로 공부
* Jdbc는 코드가 너무 복잡함 (정형화된 반복되는 코드들과 쿼리문을 직접 작성해야함)
* 스프링 JdbcTemplate는 반복되는 코드들은 줄였지만 여전히 쿼리문은 직접 작성해야함
* JPA는 해당 클래스를 엔티티로 매핑만 해주면 쿼리문까지 JPA가 알아서 작성해줌 PK를 사용하지 않는 쿼리는 JPQL로 객체 지향적으로 작성 가능, JPA는 반드시 트랜잭션 처리를 해주어야함
-> 서비스 계층에 @Transactional 어노테이션 추가
* 스프링 데이터 JPA는 한술 더 떠서 인터페이스만 작성하면 기본적인 CRUD나 페이지네이션까지 알아서 작성 가능, 디폴트로 들어가있는 쿼리가 아니면 구현하고 선언해주면 끝.
* 이렇게 DB를 바꿔가면서 실행 시킬 때 각 디비들에 대한 설정과  springConfig파일의 레포 선언만 수정해주면 됨
* 스프링 데이터 JPA는 사용자가 만든 인터페이스를 자동으로 스프링 빈으로 등록시켜주기 때문에 springConfig파일을 수정할 필요가 없음

## AOP

* 각각의 메서드나 클래스의 실행 시간을 알아보고싶다고 가정해보자. 해당 사항은 프로젝트의 핵심관심사항이 아니라 공통관심사항이다. 
* 핵심관심사항과 공통관심사항이 뒤섞이면 유지보수 측면에서 매우 까다로움, 하지만 공통관심사항을 따로 공통 로직으로 만들기도 어려운 상황.
* 이럴때 AOP를 사용함 -> AOP는 프록시기술로 가짜 스프링 빈을 생성하여 공통관심사항을 처리한 후 실제 스프링 빈을 호출하는 기술
* @Aspect 어노테이션 사용, 스프링 빈에 직접등록해도 되고, 컴포넌트 스캔(@Component)방식을 이용해도 됨.
* DI기술의 중요성(각각 들어가는 AOP마다 직접 넣어주는 것이 아니라 외부에서 자동으로 주입되게 설계 가능)


