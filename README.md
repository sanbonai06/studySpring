# studySpring

## Spring 동작 방식

* 정적 컨텐츠의 동작 : 해당 요청이 들어오면 스프링 컨테이너가 정적 컨텐츠 관련 컨트롤러를 찾으려함 정적 컨텐츠이므로 컨트롤러가 없어서 resources 내부에 있는 정적 파일을 그대로 화면으로 띄움

* MVC와 템플릿 엔진 : 해다 요청이 들어오면 스프링 컨테이너가 해당 컨트롤러를 찾음 해당 컨트롤러가 반환하는 view를 viewResolver가 찾아서 템플릿 엔진이 처리하여 화면으로 띄움

* API : 어노테이션 @ResponseBody 추가 해당 어노테이션이 추가되면 viewResolver를 사용X 대신 HTTP 응답 방식의 Body에 리턴 값을 직접 반환한다. 보통 객체를 반환한다. -> JSON형식

## 스프링 파일 터미널에서 실행하기

```
$ ./gradlew build 
$ cd /build/libs
$ java -jar [파일이름].jar
```



## 회원 레포 구현 및 테스트 케이스 생성

* 회원 객체 생성(domain) 후 레포 구현 (레포지토리 패키지 -> 멤버 레포 인터페이스 -> 메모리 멤버 레포 클래스 생성)
* 레포에서 쓸 메서드들 구현 (save, findById, findByName, findAll, clearStore) id는 sequence로 하나씩 올려가면서 시스템 자체에서 생성
* 테스트 케이스 생성 -> 테스트파일은 각각의 메서드에 의존관계 없이 생성해야함 -> 따라서 clearStore 만듦 clearStore는 AfterEach로 각각의 메서드가 끝날때맏 실행 -> 기록 지워짐
* 테스트 케이스를 먼저 생성 후 구현하는 방식의 코딩 스타일 (TTD라고 함)

## 회원 서비스 구현 및 테스트 케이스 생성

* 회원 서비스 (회원가입, 유저 리스트 조회, 아이디로 유저 조회) 구현
* 회원가입에 이름이 중복되면 회원 가입 불가 하는 로직 구현 및 리팩토링
* 테스트 케이스 생성
* 테스트 케이스 생성 중 회원 서비스에서 new로 생성하는 레포가 문제 발생 가능성이 있음을 배움
* 따라서, 직접 new로 생성하는것이 아니라 외부에서 넣어 주는 개념(DI)으로 생성자로 레포를 넣어줌
* 테스트 케이스에서 BeforeEach 어노테이션으로 모든 테스트 메서드가 실행되기전에 실행

## 컴포넌트 스캔 및 스프링 설정 파일로 스프링 컨테이너에 등록

* 스프링에서 동작하려면 Controller(외부에서 들어오는 요청 처리) - Service(로직 구현) - Repository(데이터 저장) 순으로 의존 관계가 이루어져 있어야 함.
* 모든 것이 스프링 빈으로 등록되어야지만 스프링이 관리 가능함으로 의존관계가 성립 가능
* 스프링 빈으로 등록하는 방법은 컴포넌트 스캔방식, 스프링 설정파일(SpringConfig)이용 이렇게 두가지 방식이 존재
* 컴포넌트 스캔 방식은 @Controller, @Service, @Repository의 어노테이션들을 각각 붙인 다음에 @Autowired로 생성자 주입을 통해 의존관계를 성립시켜주는 방식
* 스프링 설정파일을 통해 등록하는 방식은 직접 파일을 만든 후, @Configuration, @Bean 어노테이션을 통해 직접 등록해주는 방식
* 정형화되고 바꿀 일이 없는 클래스들은 보통 컴포넌트 스캔방식을 이용, 하지만 현재 예제에서와 같이 DB를 바꿀예정이거나 클래스들을 교체해야 하는 서비스의 경우에는 설정파일에서 쉽게 교체 가능하기 때문에 설정파일 방식을 이용

## 회원 웹 기능

* 컨트롤러에서 요청을 전달받은 뒤에 해당 요청을 처리하는 컨트롤러 속 메서드로 이동.. 해당 메서드에서 요청을 처리한 뒤에 반환값 이름을 가지는 파일로 이동하여 해당 파일을 화면에 띄움
